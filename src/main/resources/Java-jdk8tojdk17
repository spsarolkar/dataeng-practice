
ğŸš€ Advanced Java Questions (JDK 8 â†’ JDK 17 Focus)
ğŸ”¹ Core Language Features
What are the key differences between var in Java 10 and traditional type declarations?
Follow-up: Can var be used in lambda expressions or method parameters?
   ---

    # âœ… **Key Differences Between `var` (Java 10) and Traditional Type Declarations**

    ## ğŸ”¹ 1. **Type is Inferred, Not Dynamic**

    Traditional declaration:

    ```java
    String message = "Hello";
    ```

    Using `var`:

    ```java
    var message = "Hello"; // compiler infers String
    ```

    **But:** Java remains statically typed.
    `var` does **not** make Java dynamically typed like JavaScript or Python.

    ---

    ## ğŸ”¹ 2. **`var` Can Only Be Used in Local Contexts**

    You **can use `var` only for:**

    * Local variables
    * Loop variables
    * Try-with-resources variables

    âŒ You **cannot use `var` for:**

    * Method parameters
    * Method return types
    * Fields (members)
    * Constructor parameters
    * Lambda parameters

    Example (invalid):

    ```java
    public void process(var input) {} // âŒ Not allowed
    ```

    ---

    ## ğŸ”¹ 3. **Improves Readability When Type Is Obvious**

    Example where `var` improves clarity:

    ```java
    var map = new HashMap<String, List<Integer>>();
    ```

    Without `var`:

    ```java
    HashMap<String, List<Integer>> map = new HashMap<>();
    ```

    ---

    ## ğŸ”¹ 4. **But Can Hurt Readability If Misused**

    Bad:

    ```java
    var data = process(); // What type is data??
    ```

    Good:

    ```java
    var userList = getActiveUsers(); // name suggests meaning
    ```

    Always use meaningful variable names.

    ---

    ## ğŸ”¹ 5. **Cannot Be Assigned a Null Literal**

    This is invalid:

    ```java
    var x = null; // âŒ compiler cannot infer type
    ```

    ---

    ## ğŸ”¹ 6. **Type is Locked at Compile Time**

    Even if you later assign a different type â€” compiler wonâ€™t allow it.

    ```java
    var num = 10;  // inferred as int
    num = "hello"; // âŒ type mismatch
    ```

    ---

    ## ğŸ”¹ 7. **Works Great with Anonymous Types**

    Example:

    ```java
    var obj = new Object() {
        int id = 10;
    };
    ```

    Without `var`, this is impossible to type.

    ---

    # ğŸ“ **Summary Table**

    | Feature                                | `var`   | Traditional Types |
    | -------------------------------------- | ------- | ----------------- |
    | Type inferred automatically            | âœ”ï¸      | âŒ (explicit)      |
    | Compile-time static typing             | âœ”ï¸      | âœ”ï¸                |
    | Can be used for fields                 | âŒ       | âœ”ï¸                |
    | Can be used for method parameters      | âŒ       | âœ”ï¸                |
    | Useful with generics/anonymous classes | âœ”ï¸      | Limited           |
    | Improves readability                   | Depends | Usually yes       |

    ---



# Can `var` be used in lambda parameters?**

    ### âœ”ï¸ **YES â€” Java allows using `var` in lambda parameters (Java 11+)**

    Example:

    ```java
    (var x, var y) -> x + y
    ```

    This works and is legal.

    ---

    ## ğŸ”¹ **Why was this added?**

    Java 11 introduced this to allow:

    ### 1ï¸âƒ£ **Adding annotations on lambda parameters**

    Example:

    ```java
    (@NotNull var name) -> System.out.println(name);
    ```

    Before Java 11, this was impossible because annotations require explicit types.

    ---

    ### âŒ Cannot use `var` for single-parameter lambdas without parentheses

    ```java
    var x -> x * 2;  // âŒ invalid
    ```

    Correct version:

    ```java
    (var x) -> x * 2;
    ```

    ---

    ### âŒ `var` does NOT change type inference of the lambda

    This is still determined by the target functional interface.

    ---

    # ğŸ“ **Examples**

    ### âœ” Valid usage

    ```java
    (var a, var b) -> a + b
    ```

    ```java
    (@NotNull var input) -> System.out.println(input)
    ```

    ---

    ### âŒ Invalid usage

    ```java
    (a, var b) -> a + b  // âŒ mixed
    ```

    ```java
    var a -> a * 2       // âŒ missing parentheses
    ```

    ---






What is the purpose of sealed classes in Java 17?

    A sealed class explicitly lists its permitted subclasses:

    ```java
    public sealed class Shape permits Circle, Rectangle {}
    ```

    Only these two classes can extend `Shape`.


    With sealed classes, the compiler can verify that all subtypes are handled in a switch:

    ```java
    switch (shape) {
        case Circle c -> ...
        case Rectangle r -> ...
        // no default needed â€” compiler knows hierarchy is complete
    }
    ```

    This is impossible with normal classes.

    ---

    ### ğŸ”¹ 4. **Increase security**

    They prevent extension by untrusted code and reduce risk of:

    * Unexpected overriding
    * Untracked specialization
    * Accidental misuse by developers

    ---

    ### ğŸ”¹ 5. **Better alternative to â€œfinalâ€ or â€œabstractâ€ classes**

    | Modifier     | Meaning                               |
    | ------------ | ------------------------------------- |
    | **final**    | No one can extend it                  |
    | **abstract** | Anyone can extend it                  |
    | **sealed**   | *Only specific* classes can extend it |

    Sealed classes provide a **middle ground**.

    ---

    # ğŸ”¥ Example

    ```java
    public sealed class Vehicle permits Car, Bike {}

    public final class Car extends Vehicle {}
    public final class Bike extends Vehicle {}
    ```

    Only `Car` and `Bike` can extend `Vehicle`.

    ---


How does switch expression (Java 14+) improve upon classic switch?
Can you show a use case involving pattern matching?

    Here is a **concise, interview-quality explanation** of how **switch expressions (Java 14+)** improve upon classic switch statements.

    ---

    # âœ… **How Switch Expressions Improve Upon Classic Switch**

    Java 14+ introduces **switch expressions**, which are more powerful, safer, and more concise than traditional switch statements.

    ---

    # ğŸ”¹ 1. **They return values**

    Classic switch = only a *statement*, cannot return a result.

    ```java
    int result = switch (day) {
        case MONDAY -> 1;
        case TUESDAY -> 2;
        default -> 0;
    };
    ```

    This was **impossible** in classic switch.

    ---

    # ğŸ”¹ 2. **No fall-through by default**

    Classic switch falls through unless you add `break`:

    ```java
    switch(x) {
        case 1:
            // falls through accidentally
        case 2:
            ...
    }
    ```

    Switch expressions **do not fall through**, eliminating an entire class of bugs.

    ```java
    switch(x) {
        case 1 -> "one";
        case 2 -> "two";
    }
    ```

    ---

    # ğŸ”¹ 3. **Better, clearer syntax â€” â€œarrowâ€ (`->`) style**

    New switch:

    ```java
    case MONDAY -> "Start";
    ```

    Old switch:

    ```java
    case MONDAY:
        return "Start";
    ```

    Cleaner + more readable.

    ---

    # ğŸ”¹ 4. **Pattern Matching Support (modern Java)**

    Switch expressions integrate with pattern matching, enabling type-based dispatch.

    Example:

    ```java
    switch (obj) {
        case String s -> s.toUpperCase();
        case Integer i -> i * 2;
        default -> 0;
    }
    ```

    Classic switch cannot operate on anything except:

    * primitives
    * enum
    * String

    Switch expressions can handle **types**, not just values.

    ---

    # ğŸ”¹ 5. **Exhaustiveness Checking**

    Compiler ensures all possible cases are handled if switching on a **sealed type** or an **enum**.

    Example with sealed class:

    ```java
    int area = switch(shape) {
        case Circle c -> compute(c);
        case Rectangle r -> compute(r);
    }; // no default needed
    ```

    Classic switch does **not** enforce this.

    ---

    # ğŸ”¹ 6. **`yield` keyword for complex cases**

    For multi-line logic:

    ```java
    int num = switch(x) {
        case 1 -> 10;
        case 2 -> {
            int val = compute();
            yield val;  // returns a value from block
        }
        default -> 0;
    };
    ```


    ---

    # ğŸ”¥ Summary Table

    | Feature                 | Classic Switch | Switch Expression |
    | ----------------------- | -------------- | ----------------- |
    | Returns a value         | âŒ              | âœ”                 |
    | Prevents fall-through   | âŒ              | âœ”                 |
    | Arrow syntax            | âŒ              | âœ”                 |
    | Pattern matching        | âŒ              | âœ”                 |
    | Exhaustiveness checking | âŒ              | âœ”                 |
    | Multi-line with yield   | âŒ              | âœ”                 |
    | Operates on more types  | Limited        | Expanded          |

    ---




Explain the concept of Records in Java 16.

How do they compare with Lombok @Data classes?

What is the Text Blocks feature in Java 15?
    String query = """
        SELECT id, name, age
        FROM users
        WHERE active = 1
        ORDER BY age DESC
        """;


When would you use them over regular strings?


ğŸ”¹ JVM and Performance
What is the Z Garbage Collector introduced in Java 11+?

    When would you use ZGC vs G1GC?

    Here is a **chronological, interview-ready explanation** of how **Garbage Collection (GC) evolved from JVM 5 â†’ Java 17**.
    This is one of the **most common advanced Java interview questions**.

    ---

    # ğŸš€ **Evolution of Garbage Collectors in JVM (Java 5 â†’ Java 17)**

    Below is a clean timeline explaining **what GC existed, why new ones were added, and what problems they solved**.

    ---

    # ğŸŸ¦ **Java 5 (2004): Parallel GC + CMS (early days)**

    ### âœ” Parallel GC (Throughput Collector)

    * Default GC for many years
    * Multi-threaded **minor collections**
    * Objective: **maximize throughput** (do more work per unit time)
    * Still has significant **stop-the-world pauses**.

    ### âœ” CMS (Concurrent Mark-Sweep) â€” introduced earlier, matured in Java 5

    Purpose: **Low pause times**
    CMS did:

    * Concurrent marking
    * Concurrent sweeping

    But it **did not compact memory**, causing **fragmentation** and eventual *promotion failures*.

    Many enterprises used **CMS** for low-latency applications.

    ---

    # ğŸŸ© **Java 6 (2006): CMS improvements**

    CMS got tuning parameters and became more stable, but flaws remained:

    * Fragmentation
    * Many tuning knobs
    * Not ideal for very large heaps (>10â€“20 GB)

    ---

    # ğŸŸ§ **Java 7 (2011): G1GC (Garbage-First) introduced (experimental)**

    G1GC was designed to **replace CMS**.

    Key features:

    * Region-based heap
    * Predictable pause times
    * Concurrent + incremental compaction
    * Aims to meet a **soft pause-time target** (e.g., 200ms)

    This is the start of **modern GC**.

    ---

    # ğŸŸ¥ **Java 8 (2014): G1GC becomes feature complete**

    Java 8 became the most popular Java version ever â€” GC stability mattered.

    CMS still default, but:

    * G1GC became production-ready
    * Massive improvements in performance
    * G1 compacted memory, eliminating CMS fragmentation problems

    **Spark, Kafka, and many JVM frameworks were tuned around Java 8 GC behavior.**

    ---

    # ğŸŸ¨ **Java 9 (2017): G1 becomes the default GC**

    Why switch from Parallel GC â†’ G1GC?

    Because:

    * CMS was deprecated
    * Apps had larger heaps
    * Predictable pause times were more important

    New features:

    * String deduplication
    * Unified logging
    * Improvements in GC ergonomics

    This marks the shift to **pause timeâ€“first design**.

    ---

    # ğŸŸ¦ **Java 11 (2018): Two Game Changers â€” ZGC and Epsilon**

    ## âœ” **ZGC (Z Garbage Collector)** â€” Ultra-low latency

    * < 1 ms pauses
    * Concurrent compaction
    * Supports **multi-terabyte heaps**
    * Uses colored pointers

    Built for **modern, high-memory, low-latency apps** (FinTech, ML, Big Data).

    ## âœ” **Epsilon GC**

    * **No-op GC**
    * For testing or very short-lived apps
    * Provides deterministic performance without overhead

    ---

    # ğŸŸ« **Java 12 (2019): Shenandoah GC (RedHat)**

    Another **low-pause collector**, like ZGC, but implemented differently.

    Shenandoah:

    * < 10ms pauses
    * Fully concurrent compaction
    * Good for large JVM heaps
    * Originated from RedHat for Linux distros

    Java now had **two serious low-latency collectors**: ZGC + Shenandoah.

    ---

    # ğŸŸ© **Java 14â€“15: Modernization of GC**

    ### âœ” ZGC becomes production-ready (Java 15)

    ### âœ” Shenandoah also becomes production-ready

    ### âœ” CMS is **removed** from JDK

    GC landscape simplified into a modern set:

    * Serial GC (small heaps)
    * Parallel GC (throughput)
    * G1GC (default for general use)
    * ZGC (ultra-low latency)
    * Shenandoah (low latency, open-source alternative)

    ---

    # ğŸŸ¦ **Java 17 (2021 LTS): GC Maturity and Performance**

    Java 17 stabilized all collectors:

    ### âœ” ZGC improvements

    * Sub-millisecond pauses
    * Better memory usage
    * Reduced pointer coloring overhead

    ### âœ” G1 improvements

    * Better region sizing
    * Faster concurrent marking cycles

    ### âœ” Shenandoah is fully integrated

    * Predictable low-latency for large heaps

    ### âœ” JDK 17 â†’ modern GC defaults are far more stable than Java 8

    ---

    # ğŸ¯ **Summary Table â€” Evolution of GC**

    | Java Version | Collector                | Purpose                             |
    | ------------ | ------------------------ | ----------------------------------- |
    | Java 5       | Parallel GC, CMS         | Throughput / Low pause beginnings   |
    | Java 6       | CMS improvements         | Reduced pauses, still fragmentation |
    | Java 7       | G1GC introduced          | Predictable pauses                  |
    | Java 8       | G1GC stable              | Alternative to CMS                  |
    | Java 9       | G1GC default             | CMS deprecated                      |
    | Java 11      | ZGC + Epsilon            | Ultra-low latency, testing          |
    | Java 12      | Shenandoah               | Low-latency open-source GC          |
    | Java 15      | ZGC production           | Mature sub-ms GC                    |
    | Java 17      | All collectors optimized | G1 default, ZGC & Shenandoah stable |

    ---

    # ğŸ’¥ **Interview-Ready Conclusion**

    > â€œJVM GC evolved from throughput-oriented collectors like Parallel GC in Java 5, to low-pause CMS, to region-based G1 in Java 9, and eventually to ultra-low latency collectors like ZGC and Shenandoah in Java 11+. Modern Java (17+) provides GC choices for different use cases: G1 for general workloads, ZGC/Shenandoah for extremely low-latency systems, and Parallel GC for throughput-heavy applications.â€


How do JEPs help track changes in Java versions?
    JEPs (JDK Enhancement Proposals) are the official documents used to propose, specify, and track all changes in the Java platform. They describe what a feature is, why it exists, how it works, and which Java version includes it. JEPs make it easy for developers to track new features, plan upgrades, understand JVM and language changes, and follow the evolution of Java in a structured and transparent manner.


Can you name 2 important JEPs from Java 14 to 17?

    What is CDS (Class Data Sharing) and how does it improve startup performance?

    Here are **two important JEPs from Java 14 â†’ 17**, with short, interview-ready explanations.

    ---

    # âœ… **1. JEP 395 â€“ Records (Java 16)**

    Records introduce **concise, immutable data carrier classes**.

    Example:

    ```java
    public record Person(String name, int age) {}
    ```

    Why important?

    * Eliminates boilerplate (constructor, getters, equals/hashCode, toString)
    * Better modeling for DTOs, events, API responses
    * Works perfectly with sealed classes + pattern matching

    ---

    # âœ… **2. JEP 409 â€“ Sealed Classes (Java 17)**

    Sealed classes allow **controlled inheritance**, specifying exactly which classes may extend a class or interface.

    Example:

    ```java
    public sealed interface Shape permits Circle, Square {}
    ```

    ---

    # â­ Bonus JEPs (Mention these if interviewer asks for more)**

    ### âœ” JEP 361 â€“ Switch Expressions (Java 14)

    Enables switch to return values and eliminate fall-through.

    ### âœ” JEP 378 â€“ Text Blocks (Java 15)

    Adds multiline strings using triple quotes (`"""`).

    ### âœ” JEP 377 â€“ ZGC Production (Java 15)

    Ultra-low latency GC with <1ms pauses.

    ### âœ” JEP 391 â€“ macOS/AArch64 Port (Java 17)

    Support for Apple Silicon (M1/M2).

    ---

ğŸ”¹ Collections and APIs
What are the key additions to the Collectors API since Java 8?
    1. Collectors.filtering() (Java 9)
        Before
        Map<String, List<Employee>> result =
            employees.stream()
                .filter(e -> e.getAge() > 30)
                .collect(groupingBy(Employee::getDept));
        After
        Map<String, List<Employee>> result =
        employees.stream()
            .collect(groupingBy(Employee::getDept,
                filtering(e -> e.getAge() > 30, toList())));
        * Essential for nested collectors, multi-level grouping, conditional grouping.

    2. Collectors.flatMapping()
        Map<String, List<String>> phones =
        users.stream()
            .collect(groupingBy(User::getCity,
                flatMapping(u -> u.getPhones().stream(), toList())));

    3. Collectors.collectingAndThen()
        List<String> names = list.stream()
        .collect(collectingAndThen(toList(), List::copyOf));

    4. Collectors.teeing()
        var result = numbers.stream()
        .collect(teeing(
            minBy(Integer::compareTo),
            maxBy(Integer::compareTo),
            (min, max) -> Map.of("min", min.get(), "max", max.get())
        ));
        Why important?
        Avoids double streaming
        Cleaner and more declarative aggregation logic
        Very useful for analytics-style code
    5. var result = numbers.stream()
        .collect(teeing(
            minBy(Integer::compareTo),
            maxBy(Integer::compareTo),
            (min, max) -> Map.of("min", min.get(), "max", max.get())
        ));
    6. List<String> list = stream.collect(toUnmodifiableList());





How would you use Collectors.teeing() introduced in Java 12?

What changes were made to Optional since Java 8?

    1. ifPresentOrElse()- Allows handling both present and empty cases without an explicit else.
        opt.ifPresentOrElse(
            value -> System.out.println("Value: " + value),
            () -> System.out.println("Empty")
        );

    2. or() - It allows lazy fallback, unlike orElse() which eagerly evaluates arguments.

        Optional<String> result =
        opt.or(() -> Optional.of("default"));
    3. stream() - Turns an Optional into a Stream of 0 or 1 elements. Useful for functional pipelines, flatMap chains.
        Stream<String> stream = opt.stream();

How does Optional.or() (Java 9) simplify default value logic?
    orElse() vs orElseGet() vs or()
        orElse()
            Optional<String> opt = Optional.empty();
            String result = opt.orElse(getDefault()); <-Important: getDefault() is always executed, even if the Optional is not empty.->

        orElseGet() â€“ Lazy fallback (Supplier)
            String result = opt.orElseGet(() -> getDefault());

        or() â€“ Lazy fallback, but returns another Optional (Java 9)
            Optional<String> result =
                opt.or(() -> Optional.of("fallback"));



ğŸ”¹ Concurrency & Flow Control
What is the Flow API introduced in Java 9?

How is it related to the Reactive Streams specification?

How does CompletableFuture.delayedExecutor() (Java 9) differ from ScheduledExecutorService?

What enhancements were made to ThreadLocalRandom in recent Java versions?

ğŸ”¹ Tooling & JVM Internals
Whatâ€™s new in the jlink and jmod tools introduced with Java 9?

How would you use them to ship a minimal runtime?

How does the new --enable-preview flag work in Java?

What are the risks of using preview features in production?

ğŸ”¹ Project-Oriented and Modern Practices
How does Javaâ€™s module system (JPMS) help in securing large codebases?

Compare it with OSGi if relevant.

What are the limitations or challenges you might face when migrating a Java 8 project to Java 17?

âœ… Bonus Spark-Relevant Integration Questions
How does Spark's support for JDK 17 differ from earlier versions?

Any compatibility issues you've encountered?

Can you use Records as typed Dataset beans in Spark Structured Streaming?

Would using Text Blocks help in writing multiline SQL queries inside Spark apps?




---------------------------------------------------------------------------------------------------





âœ… Java 9
1. ğŸ” Factory Methods for Collections
New static methods on interfaces like List, Set, and Map for immutable collections.

java
Copy
Edit
List<String> list = List.of("A", "B", "C");
Set<Integer> set = Set.of(1, 2, 3);
Map<String, Integer> map = Map.of("A", 1, "B", 2);
Immutable by default

Throws UnsupportedOperationException on mutation attempts

2. ğŸ”„ Map.ofEntries(...)
For maps with more than 10 key-value pairs:

java
Copy
Edit
Map<String, String> map = Map.ofEntries(
    Map.entry("key1", "val1"),
    Map.entry("key2", "val2")
);
âœ… Java 10
3. ğŸ’¡ copyOf() Methods
Creates unmodifiable copies from existing collections.

java
Copy
Edit
List<String> copy = List.copyOf(existingList);
If the original list is already unmodifiable, no copy is made.

Great for defensive copying in APIs.

âœ… Java 11
4. ğŸš€ Performance Improvements
Internally optimized collection factories (e.g., List.of) for better memory usage and iteration speed.

âœ… Java 12
5. ğŸ§ª Collectors.teeing() â€” Advanced Stream Aggregation
Combines two downstream collectors and merges the results.

java
Copy
Edit
var result = Stream.of(1, 2, 3, 4, 5)
    .collect(Collectors.teeing(
        Collectors.summingInt(i -> i),
        Collectors.counting(),
        (sum, count) -> sum / count
    ));
â¡ Calculates average manually
ğŸ§  Powerful when .averagingInt() doesnâ€™t fit complex logic.

âœ… Java 14â€“17
6. ğŸ“ˆ Internal Optimizations
JDK team has continued improving spliterator, parallel stream, and ConcurrentHashMap internals for performance and lower GC pressure.

7. ğŸ“ toList() on Stream (Java 16+)
Simpler and more readable:

java
Copy
Edit
List<String> list = stream.toList(); // Instead of collect(Collectors.toList())
ğŸ§  Interview-Ready Summary

Version	Feature
Java 9	List.of(), Set.of(), Map.of(), Map.ofEntries()
Java 10	copyOf() methods
Java 12	Collectors.teeing()
Java 16	Stream.toList()
Java 9â€“17	Many internal enhancements for performance and memory efficiency
